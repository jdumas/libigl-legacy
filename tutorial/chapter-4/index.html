



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-0.17.3, mkdocs-material-2.7.0">
    
    
      
        <title>Chapter 4: Shape Deformation - libigl</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.78aab2dc.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.6079476c.css">
      
    
    
      <script src="../../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="light-blue" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <a href="#chapter-4-shape-deformation" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="libigl" class="md-header-nav__button md-logo">
          
            <i class="md-icon">details</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                libigl
              </span>
              <span class="md-header-nav__topic">
                Chapter 4: Shape Deformation
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <span class="md-nav__button md-logo">
      
        <i class="md-icon">details</i>
      
    </span>
    libigl
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      Tutorial
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Tutorial
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-1/" title="Chapter 1: Introduction to libigl" class="md-nav__link">
      Chapter 1: Introduction to libigl
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-2/" title="Chapter 2: Discrete Geometric Quantities and Operators" class="md-nav__link">
      Chapter 2: Discrete Geometric Quantities and Operators
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-3/" title="Chapter 3: Matrices and Linear Algebra" class="md-nav__link">
      Chapter 3: Matrices and Linear Algebra
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="toc">
        Chapter 4: Shape Deformation
      </label>
    
    <a href="./" title="Chapter 4: Shape Deformation" class="md-nav__link md-nav__link--active">
      Chapter 4: Shape Deformation
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#biharmonic-deformation" title="Biharmonic deformation" class="md-nav__link">
    Biharmonic deformation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-surfaces" title="Biharmonic surfaces" class="md-nav__link">
    Biharmonic surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation-fields" title="Biharmonic deformation fields" class="md-nav__link">
    Biharmonic deformation fields
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" title="Relationship to "differential coordinates" and Laplacian surface editing" class="md-nav__link">
    Relationship to "differential coordinates" and Laplacian surface editing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#polyharmonic-deformation" title="Polyharmonic deformation" class="md-nav__link">
    Polyharmonic deformation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounded-biharmonic-weights" title="Bounded biharmonic weights" class="md-nav__link">
    Bounded biharmonic weights
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dual-quaternion-skinning" title="Dual quaternion skinning" class="md-nav__link">
    Dual quaternion skinning
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#as-rigid-as-possible" title="As-rigid-as-possible" class="md-nav__link">
    As-rigid-as-possible
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fast-automatic-skinning-transformations" title="Fast automatic skinning transformations" class="md-nav__link">
    Fast automatic skinning transformations
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arap-with-grouped-edge-sets" title="ARAP with grouped edge-sets" class="md-nav__link">
    ARAP with grouped edge-sets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#biharmonic-coordinates" title="Biharmonic Coordinates" class="md-nav__link">
    Biharmonic Coordinates
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-5/" title="Chapter 5: Parametrization" class="md-nav__link">
      Chapter 5: Parametrization
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-6/" title="Chapter 6: External libraries" class="md-nav__link">
      Chapter 6: External libraries
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-7/" title="Chapter 7: Miscellaneous" class="md-nav__link">
      Chapter 7: Miscellaneous
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-8/" title="Chapter 8: Outlook for continuing development" class="md-nav__link">
      Chapter 8: Outlook for continuing development
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Compilation
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Compilation
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../example-project/" title="Example Project" class="md-nav__link">
      Example Project
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../static-library/" title="Static Library" class="md-nav__link">
      Static Library
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../third-party/" title="External Dependencies" class="md-nav__link">
      External Dependencies
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Contributing
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Contributing
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../style-guidelines/" title="Style Guidelines" class="md-nav__link">
      Style Guidelines
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../CONTRIBUTING/" title="Bug Report" class="md-nav__link">
      Bug Report
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../before-submitting-pull-request/" title="Creating a Pull Request" class="md-nav__link">
      Creating a Pull Request
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unit-tests/" title="Unit Tests" class="md-nav__link">
      Unit Tests
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Misc
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Misc
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../coding-guidelines/" title="Coding Tips" class="md-nav__link">
      Coding Tips
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../faq/" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      About
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        About
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../RELEASE_HISTORY/" title="Release History" class="md-nav__link">
      Release History
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../LICENSE/" title="License" class="md-nav__link">
      License
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#biharmonic-deformation" title="Biharmonic deformation" class="md-nav__link">
    Biharmonic deformation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-surfaces" title="Biharmonic surfaces" class="md-nav__link">
    Biharmonic surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation-fields" title="Biharmonic deformation fields" class="md-nav__link">
    Biharmonic deformation fields
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" title="Relationship to "differential coordinates" and Laplacian surface editing" class="md-nav__link">
    Relationship to "differential coordinates" and Laplacian surface editing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#polyharmonic-deformation" title="Polyharmonic deformation" class="md-nav__link">
    Polyharmonic deformation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounded-biharmonic-weights" title="Bounded biharmonic weights" class="md-nav__link">
    Bounded biharmonic weights
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dual-quaternion-skinning" title="Dual quaternion skinning" class="md-nav__link">
    Dual quaternion skinning
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#as-rigid-as-possible" title="As-rigid-as-possible" class="md-nav__link">
    As-rigid-as-possible
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fast-automatic-skinning-transformations" title="Fast automatic skinning transformations" class="md-nav__link">
    Fast automatic skinning transformations
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arap-with-grouped-edge-sets" title="ARAP with grouped edge-sets" class="md-nav__link">
    ARAP with grouped edge-sets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#biharmonic-coordinates" title="Biharmonic Coordinates" class="md-nav__link">
    Biharmonic Coordinates
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="chapter-4-shape-deformation">Chapter 4: Shape deformation<a class="headerlink" href="#chapter-4-shape-deformation" title="Permanent link">&para;</a></h1>
<p>Modern mesh-based shape deformation methods satisfy user deformation
constraints at handles (selected vertices or regions on the mesh) and propagate
these handle deformations to the rest of shape <em>smoothly</em> and <em>without removing
or distorting details</em>. Libigl provides implementations of a variety of
state-of-the-art deformation techniques, ranging from quadratic mesh-based
energy minimizers, to skinning methods, to non-linear elasticity-inspired
techniques.</p>
<h2 id="biharmonic-deformation">Biharmonic deformation<a class="headerlink" href="#biharmonic-deformation" title="Permanent link">&para;</a></h2>
<p>The period of research between 2000 and 2010 produced a collection of
techniques that cast the problem of handle-based shape deformation as a
quadratic energy minimization problem or equivalently the solution to a linear
partial differential equation.</p>
<p>There are many flavors of these techniques, but a prototypical subset are those
that consider solutions to the bi-Laplace equation, that is a biharmonic
function [#botsch_2004][]. This fourth-order PDE provides sufficient
flexibility in boundary conditions to ensure <span><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span> continuity at handle
constraints (in the limit under refinement) [#jacobson_mixed_2010][].</p>
<h3 id="biharmonic-surfaces">Biharmonic surfaces<a class="headerlink" href="#biharmonic-surfaces" title="Permanent link">&para;</a></h3>
<p>Let us first begin our discussion of biharmonic <em>deformation</em>, by considering
biharmonic <em>surfaces</em>. We will casually define biharmonic surfaces as surface
whose <em>position functions</em> are biharmonic with respect to some initial
parameterization:</p>
<p><span><span class="MathJax_Preview">\Delta^2 \mathbf{x}' = 0</span><script type="math/tex">\Delta^2 \mathbf{x}' = 0</script></span></p>
<p>and subject to some handle constraints, conceptualized as "boundary
conditions":</p>
<p><span><span class="MathJax_Preview">\mathbf{x}'_{b} = \mathbf{x}_{bc}.</span><script type="math/tex">\mathbf{x}'_{b} = \mathbf{x}_{bc}.</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{x}'</span><script type="math/tex">\mathbf{x}'</script></span> is the unknown 3D position of a point on the surface. So we
are asking that the bi-Laplacian of each of spatial coordinate function to be
zero.</p>
<p>In libigl, one can solve a biharmonic problem with <code class="codehilite">igl::harmonic</code>
and setting <span><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span> (<em>bi</em>-harmonic):</p>
<div class="codehilite"><pre><span></span><span class="c1">// U_bc contains deformation of boundary vertices b</span>
<span class="n">igl</span><span class="o">::</span><span class="n">harmonic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">U_bc</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</pre></div>

<p>This produces a smooth surface that interpolates the handle constraints, but all
original details on the surface will be <em>smoothed away</em>. Most obviously, if the
original surface is not already biharmonic, then giving all handles the
identity deformation (keeping them at their rest positions) will <strong>not</strong>
reproduce the original surface. Rather, the result will be the biharmonic
surface that does interpolate those handle positions.</p>
<p>Thus, we may conclude that this is not an intuitive technique for shape
deformation.</p>
<h3 id="biharmonic-deformation-fields">Biharmonic deformation fields<a class="headerlink" href="#biharmonic-deformation-fields" title="Permanent link">&para;</a></h3>
<p>Now we know that one useful property for a deformation technique is "rest pose
reproduction": applying no deformation to the handles should apply no
deformation to the shape.</p>
<p>To guarantee this by construction we can work with <em>deformation fields</em> (ie.
displacements)
<span><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span> rather
than directly with positions <span><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>. Then the deformed positions can be
recovered as</p>
<p><span><span class="MathJax_Preview">\mathbf{x}' = \mathbf{x}+\mathbf{d}.</span><script type="math/tex">\mathbf{x}' = \mathbf{x}+\mathbf{d}.</script></span></p>
<p>A smooth deformation field <span><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span> which interpolates the deformation
fields of the handle constraints will impose a smooth deformed shape
<span><span class="MathJax_Preview">\mathbf{x}'</span><script type="math/tex">\mathbf{x}'</script></span>. Naturally, we consider <em>biharmonic deformation fields</em>:</p>
<p><span><span class="MathJax_Preview">\Delta^2 \mathbf{d} = 0</span><script type="math/tex">\Delta^2 \mathbf{d} = 0</script></span></p>
<p>subject to the same handle constraints, but rewritten in terms of their implied
deformation field at the boundary (handles):</p>
<p><span><span class="MathJax_Preview">\mathbf{d}_b = \mathbf{x}_{bc} - \mathbf{x}_b.</span><script type="math/tex">\mathbf{d}_b = \mathbf{x}_{bc} - \mathbf{x}_b.</script></span></p>
<p>Again we can use <code class="codehilite">igl::harmonic</code> with <span><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span>, but this time solve for the
deformation field and then recover the deformed positions:</p>
<div class="codehilite"><pre><span></span><span class="c1">// U_bc contains deformation of boundary vertices b</span>
<span class="n">D_bc</span> <span class="o">=</span> <span class="n">U_bc</span> <span class="o">-</span> <span class="n">igl</span><span class="o">::</span><span class="n">slice</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">harmonic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">D_bc</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">D</span><span class="p">);</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">V</span><span class="o">+</span><span class="n">D</span><span class="p">;</span>
</pre></div>

<p><img alt="The BiharmonicDeformation example deforms a statue's head as a _biharmonic
surface_ (top) and using a _biharmonic displacements_
(bottom)." src="../images/max-biharmonic.jpg" /></p>
<h4 id="relationship-to-differential-coordinates-and-laplacian-surface-editing">Relationship to "differential coordinates" and Laplacian surface editing<a class="headerlink" href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" title="Permanent link">&para;</a></h4>
<p>Biharmonic functions (whether positions or displacements) are solutions to the
bi-Laplace equation, but also minimizers of the "Laplacian energy". For
example, for displacements <span><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span>, the energy reads</p>
<p><span><span class="MathJax_Preview">\int\limits_S \|\Delta \mathbf{d}\|^2 dA,</span><script type="math/tex">\int\limits_S \|\Delta \mathbf{d}\|^2 dA,</script></span></p>
<p>where we define <span><span class="MathJax_Preview">\Delta \mathbf{d}</span><script type="math/tex">\Delta \mathbf{d}</script></span> to simply apply the Laplacian
coordinate-wise.</p>
<p>By linearity of the Laplace(-Beltrami) operator we can reexpress this energy in
terms of the original positions <span><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> and the unknown positions
<span><span class="MathJax_Preview">\mathbf{x}' = \mathbf{x} - \mathbf{d}</span><script type="math/tex">\mathbf{x}' = \mathbf{x} - \mathbf{d}</script></span>:</p>
<p><span><span class="MathJax_Preview">\int\limits_S \|\Delta (\mathbf{x}' - \mathbf{x})\|^2 dA = \int\limits_S
 \|\Delta \mathbf{x}' - \Delta \mathbf{x})\|^2 dA.</span><script type="math/tex">\int\limits_S \|\Delta (\mathbf{x}' - \mathbf{x})\|^2 dA = \int\limits_S
 \|\Delta \mathbf{x}' - \Delta \mathbf{x})\|^2 dA.</script></span></p>
<p>In the early work of Sorkine et al., the quantities <span><span class="MathJax_Preview">\Delta \mathbf{x}'</span><script type="math/tex">\Delta \mathbf{x}'</script></span> and
<span><span class="MathJax_Preview">\Delta \mathbf{x}</span><script type="math/tex">\Delta \mathbf{x}</script></span> were dubbed "differential coordinates" [#sorkine_2004][].
Their deformations (without linearized rotations) is thus equivalent to
biharmonic deformation fields.</p>
<h2 id="polyharmonic-deformation">Polyharmonic deformation<a class="headerlink" href="#polyharmonic-deformation" title="Permanent link">&para;</a></h2>
<p>We can generalize biharmonic deformation by considering different powers of
the Laplacian, resulting in a series of PDEs of the form:</p>
<p><span><span class="MathJax_Preview">\Delta^k \mathbf{d} = 0.</span><script type="math/tex">\Delta^k \mathbf{d} = 0.</script></span></p>
<p>with <span><span class="MathJax_Preview">k\in{1,2,3,\dots}</span><script type="math/tex">k\in{1,2,3,\dots}</script></span>. The choice of <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> determines the level of continuity
at the handles. In particular, <span><span class="MathJax_Preview">k=1</span><script type="math/tex">k=1</script></span> implies <span><span class="MathJax_Preview">C^0</span><script type="math/tex">C^0</script></span> at the boundary, <span><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span>
implies <span><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span>, <span><span class="MathJax_Preview">k=3</span><script type="math/tex">k=3</script></span> implies <span><span class="MathJax_Preview">C^2</span><script type="math/tex">C^2</script></span> and in general <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> implies <span><span class="MathJax_Preview">C^{k-1}</span><script type="math/tex">C^{k-1}</script></span>.</p>
<div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="c1">// or 1,3,4,...</span>
<span class="n">igl</span><span class="o">::</span><span class="n">harmonic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">Z</span><span class="p">);</span>
</pre></div>

<p><img alt="The PolyharmonicDeformation example deforms a flat domain (left) into a bump as a
solution to various kk-harmonic PDEs." src="../images/bump-k-harmonic.jpg" /></p>
<h2 id="bounded-biharmonic-weights">Bounded biharmonic weights<a class="headerlink" href="#bounded-biharmonic-weights" title="Permanent link">&para;</a></h2>
<p>In computer animation, shape deformation is often referred to as "skinning".
Constraints are posed as relative rotations of internal rigid "bones" inside a
character. The deformation method, or skinning method, determines how the
surface of the character (i.e. its skin) should move as a function of the bone
rotations.</p>
<p>The most popular technique is linear blend skinning. Each point on the shape
computes its new location as a linear combination of bone transformations:</p>
<p><span><span class="MathJax_Preview">\mathbf{x}' = \sum\limits_{i = 1}^m w_i(\mathbf{x}) \mathbf{T}_i
 \left(\begin{array}{c}\mathbf{x}_i\\1\end{array}\right),</span><script type="math/tex">\mathbf{x}' = \sum\limits_{i = 1}^m w_i(\mathbf{x}) \mathbf{T}_i
 \left(\begin{array}{c}\mathbf{x}_i\\1\end{array}\right),</script></span></p>
<p>where <span><span class="MathJax_Preview">w_i(\mathbf{x})</span><script type="math/tex">w_i(\mathbf{x})</script></span> is the scalar <em>weight function</em> of the ith bone evaluated at
<span><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> and <span><span class="MathJax_Preview">\mathbf{T}_i</span><script type="math/tex">\mathbf{T}_i</script></span> is the bone transformation as a <span><span class="MathJax_Preview">4 \times 3</span><script type="math/tex">4 \times 3</script></span>
matrix.</p>
<p>This formula is embarassingly parallel (computation at one point does not
depend on shared data need by computation at another point). It is often
implemented as a vertex shader. The weights and rest positions for each vertex
are sent as vertex shader <em>attributes</em> and bone transformations are sent as
<em>uniforms</em>. Then vertices are transformed within the vertex shader, just in
time for rendering.</p>
<p>As the skinning formula is linear (hence its name), we can write it as matrix
multiplication:</p>
<p><span><span class="MathJax_Preview">\mathbf{X}' = \mathbf{M} \mathbf{T},</span><script type="math/tex">\mathbf{X}' = \mathbf{M} \mathbf{T},</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> is <span><span class="MathJax_Preview">n \times 3</span><script type="math/tex">n \times 3</script></span> stack of deformed positions as row
vectors, <span><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span> is a <span><span class="MathJax_Preview">n \times m\cdot dim</span><script type="math/tex">n \times m\cdot dim</script></span> matrix containing weights and
rest positions and <span><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span> is a <span><span class="MathJax_Preview">m\cdot (dim+1) \times dim</span><script type="math/tex">m\cdot (dim+1) \times dim</script></span> stack of
transposed bone transformations.</p>
<p>Traditionally, the weight functions <span><span class="MathJax_Preview">w_j</span><script type="math/tex">w_j</script></span> are painted manually by skilled
rigging professionals. Modern techniques now exist to compute weight functions
automatically given the shape and a description of the skeleton (or in general
any handle structure such as a cage, collection of points, selected regions,
etc.).</p>
<p>Bounded biharmonic weights are one such technique that casts weight computation
as a constrained optimization problem [#jacobson_2011][]. The weights enforce
smoothness by minimizing the familiar Laplacian energy:</p>
<p><span><span class="MathJax_Preview">\sum\limits_{i = 1}^m \int_S (\Delta w_i)^2 dA</span><script type="math/tex">\sum\limits_{i = 1}^m \int_S (\Delta w_i)^2 dA</script></span></p>
<p>subject to constraints which enforce interpolation of handle constraints:</p>
<p><span><span class="MathJax_Preview">w_i(\mathbf{x}) = \begin{cases} 1 &amp; \text{ if } \mathbf{x} \in H_i\\ 0 &amp;
 \text{ otherwise } \end{cases},</span><script type="math/tex">w_i(\mathbf{x}) = \begin{cases} 1 & \text{ if } \mathbf{x} \in H_i\\ 0 &
 \text{ otherwise } \end{cases},</script></span></p>
<p>where <span><span class="MathJax_Preview">H_i</span><script type="math/tex">H_i</script></span> is the ith handle, and constraints which enforce non-negativity,
parition of unity and encourage sparsity:</p>
<p><span><span class="MathJax_Preview">0\le w_i \le 1</span><script type="math/tex">0\le w_i \le 1</script></span> and <span><span class="MathJax_Preview">\sum\limits_{i=1}^m w_i = 1.</span><script type="math/tex">\sum\limits_{i=1}^m w_i = 1.</script></span></p>
<p>This is a quadratic programming problem and libigl solves it using its active
set solver or by calling out to <a href="http://www.mosek.com">Mosek</a>.</p>
<p><img alt="The example BoundedBiharmonicWeights computes weights for a tetrahedral
mesh given a skeleton (top) and then animates a linear blend skinning
deformation (bottom)." src="../images/hand-bbw.jpg" /></p>
<h2 id="dual-quaternion-skinning">Dual quaternion skinning<a class="headerlink" href="#dual-quaternion-skinning" title="Permanent link">&para;</a></h2>
<p>Even with high quality weights, linear blend skinning is limited. In
particular, it suffers from known artifacts stemming from blending rotations as
as matrices: a weight combination of rotation matrices is not necessarily a
rotation. Consider an equal blend between rotating by <span><span class="MathJax_Preview">-\pi/2</span><script type="math/tex">-\pi/2</script></span> and by <span><span class="MathJax_Preview">\pi/2</span><script type="math/tex">\pi/2</script></span>
about the <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-axis. Intuitively one might expect to get the identity matrix,
but instead the blend is a degenerate matrix scaling the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>
coordinates by zero:</p>
<p><span><span class="MathJax_Preview">0.5\left(\begin{array}{ccc}0&amp;-1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{array}\right)+
 0.5\left(\begin{array}{ccc}0&amp;1&amp;0\\-1&amp;0&amp;0\\0&amp;0&amp;1\end{array}\right)=
 \left(\begin{array}{ccc}0&amp;0&amp;0\\0&amp;0&amp;0\\0&amp;0&amp;1\end{array}\right)</span><script type="math/tex">0.5\left(\begin{array}{ccc}0&-1&0\\1&0&0\\0&0&1\end{array}\right)+
 0.5\left(\begin{array}{ccc}0&1&0\\-1&0&0\\0&0&1\end{array}\right)=
 \left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&1\end{array}\right)</script></span></p>
<p>In practice, this means the shape shrinks and collapses in regions where bone
weights overlap: near joints.</p>
<p>Dual quaternion skinning presents a solution [#kavan_2008]. This method
represents rigid transformations as a pair of unit quaternions,
<span><span class="MathJax_Preview">\hat{\mathbf{q}}</span><script type="math/tex">\hat{\mathbf{q}}</script></span>. The linear blend skinning formula is replaced with a
linear blend of dual quaternions:</p>
<p><span><span class="MathJax_Preview">\mathbf{x}' =
 \cfrac{\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}}
 {\left\|\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}\right\|}
 \mathbf{x},</span><script type="math/tex">\mathbf{x}' =
 \cfrac{\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}}
 {\left\|\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}\right\|}
 \mathbf{x},</script></span></p>
<p>where <span><span class="MathJax_Preview">\hat{\mathbf{q}_i}</span><script type="math/tex">\hat{\mathbf{q}_i}</script></span> is the dual quaternion representation of the rigid
transformation of bone <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>. The normalization forces the result of the linear
blending to again be a unit dual quaternion and thus also a rigid
transformation.</p>
<p>Like linear blend skinning, dual quaternion skinning is best performed in the
vertex shader. The only difference being that bone transformations are sent as
dual quaternions rather than affine transformation matrices.  Libigl supports
CPU-side dual quaternion skinning with the <code class="codehilite">igl::dqs</code> function, which takes a
more traditional representation of rigid transformations as input and
internally converts to the dual quaternion representation before blending:</p>
<div class="codehilite"><pre><span></span><span class="c1">// vQ is a list of rotations as quaternions</span>
<span class="c1">// vT is a list of translations</span>
<span class="n">igl</span><span class="o">::</span><span class="n">dqs</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">vQ</span><span class="p">,</span><span class="n">vT</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</pre></div>

<p><img alt="The example DualQuaternionSkinning compares linear blend skinning (top) to dual
quaternion skinning (bottom), highlighting LBS's candy wrapper effect (middle)
and joint collapse (right)." src="../images/arm-dqs.jpg" /></p>
<h2 id="as-rigid-as-possible">As-rigid-as-possible<a class="headerlink" href="#as-rigid-as-possible" title="Permanent link">&para;</a></h2>
<p>Skinning and other linear methods for deformation are inherently limited.
Difficult arises especially when large rotations are imposed by the handle
constraints.</p>
<p>In the context of energy-minimization approaches, the problem stems from
comparing positions (our displacements) in the coordinate frame of the
undeformed shape. These quadratic energies are at best invariant to global
rotations of the entire shape, but not smoothly varying local rotations. Thus
linear techniques will not produce non-trivial bending and twisting.</p>
<p>Furthermore, when considering solid shapes (e.g. discretized with tetrahedral
meshes) linear methods struggle to maintain local volume, and they often suffer from
shrinking and bulging artifacts.</p>
<p>Non-linear deformation techniques present a solution to these problems.
They work by comparing the deformation of a mesh
vertex to its rest position <em>rotated</em> to a new coordinate frame which best
matches the deformation. The non-linearity stems from the mutual dependence of
the deformation and the best-fit rotation. These techniques are often labeled
"as-rigid-as-possible" as they penalize the sum of all local deformations'
deviations from rotations.</p>
<p>To arrive at such an energy, let's consider a simple per-triangle energy:</p>
<p><span><span class="MathJax_Preview">E_\text{linear}(\mathbf{X}') = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right) -
 \left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2</span><script type="math/tex">E_\text{linear}(\mathbf{X}') = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right) -
 \left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> are the mesh's unknown deformed vertex positions, <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> is a
triangle in a list of triangles <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, <span><span class="MathJax_Preview">a_t</span><script type="math/tex">a_t</script></span> is the area of triangle <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> and
<span><span class="MathJax_Preview">\{i,j\}</span><script type="math/tex">\{i,j\}</script></span> is an edge in triangle <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>. Thus, this energy measures the norm of
change between an edge vector in the original mesh <span><span class="MathJax_Preview">\left(\mathbf{x}_i -
\mathbf{x}_j\right)</span><script type="math/tex">\left(\mathbf{x}_i -
\mathbf{x}_j\right)</script></span> and the unknown mesh <span><span class="MathJax_Preview">\left(\mathbf{x}'_i -
\mathbf{x}'_j\right)</span><script type="math/tex">\left(\mathbf{x}'_i -
\mathbf{x}'_j\right)</script></span>.</p>
<p>This energy is <strong>not</strong> rotation invariant. If we rotate the mesh by 90 degrees
the change in edge vectors not aligned with the axis of rotation will be large,
despite the overall deformation being perfectly rigid.</p>
<p>So, the "as-rigid-as-possible" solution is to append auxiliary variables
<span><span class="MathJax_Preview">\mathbf{R}_t</span><script type="math/tex">\mathbf{R}_t</script></span>
for each triangle <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> which are constrained to be rotations. Then the energy is
rewritten, this time comparing deformed edge vectors to their rotated rest
counterparts:</p>
<p><span><span class="MathJax_Preview">E_\text{arap}(\mathbf{X}',\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}) = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right)-
 \mathbf{R}_t\left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2.</span><script type="math/tex">E_\text{arap}(\mathbf{X}',\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}) = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right)-
 \mathbf{R}_t\left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2.</script></span></p>
<p>The separation into the primary vertex position variables <span><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> and the
rotations <span><span class="MathJax_Preview">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</span><script type="math/tex">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</script></span> lead to strategy for
optimization, too. If the rotations <span><span class="MathJax_Preview">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</span><script type="math/tex">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</script></span>
are held fixed then the energy is quadratic in the remaining variables
<span><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> and can be optimized by solving a (sparse) global linear system.
Alternatively, if <span><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> are held fixed then each rotation is the
solution to a localized <em>Procrustes</em> problem (found via <span><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> SVD or
polar decompostion). These two steps---local and global---each weakly decrease
the energy, thus we may safely iterate them until convergence.</p>
<p>The different flavors of "as-rigid-as-possible" depend on the dimension and
codimension of the domain and the edge-sets <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>. The proposed surface
manipulation technique by Sorkine and Alexa [#sorkine_2007][], considers <span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> to
be the set of sets of edges emanating from each vertex (spokes). Later, Chao et
al.  derived the relationship between "as-rigid-as-possible" mesh energies and
co-rotational elasticity considering 0-codimension elements as edge-sets:
triangles in 2D and tetrahedra in 3D [#chao_2010][]. They also showed how
Sorkine and Alexa's edge-sets are not a discretization of a continuous energy,
proposing instead edge-sets for surfaces containing all edges of elements
incident on a vertex (spokes and rims). They show that this amounts to
measuring bending, albeit in a discretization-dependent way.</p>
<p>Libigl, supports these common flavors. Selecting one is a matter of setting the
energy type before the precompuation phase:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">ARAPData</span> <span class="n">arap_data</span><span class="p">;</span>
<span class="n">arap_data</span><span class="p">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">igl</span><span class="o">::</span><span class="n">ARAP_ENERGY_TYPE_SPOKES</span><span class="p">;</span>
<span class="c1">//arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES_AND_RIMS;</span>
<span class="c1">//arap_data.energy = igl::ARAP_ENERGY_TYPE_ELEMENTS; //triangles or tets</span>
<span class="n">igl</span><span class="o">::</span><span class="n">arap_precomputation</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">arap_data</span><span class="p">);</span>
</pre></div>

<p>Just like <code class="codehilite">igl::min_quad_with_fixed_*</code>, this precomputation phase only depends
on the mesh, fixed vertex indices <code class="codehilite">b</code> and the energy parameters. To solve with
certain constraints on the positions of vertices in <code class="codehilite">b</code>, we may call:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">arap_solve</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span><span class="n">arap_data</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</pre></div>

<p>which uses <code class="codehilite">U</code> as an initial guess and then computes the solution into it.</p>
<p>Libigl's implementation of as-rigid-as-possible deformation takes advantage of
the highly optimized singular value decomposition code from McAdams et al.
[#mcadams_2011][] which leverages SSE intrinsics.</p>
<p><img alt="The example AsRigidAsPossible deforms a surface as if it were made of an
elastic material" src="../images/decimated-knight-arap.jpg" /></p>
<p>The concept of local rigidity will be revisited shortly in the context of
surface parameterization.</p>
<h2 id="fast-automatic-skinning-transformations">Fast automatic skinning transformations<a class="headerlink" href="#fast-automatic-skinning-transformations" title="Permanent link">&para;</a></h2>
<p>Non-linear optimization is, unsurprisingly, slower than its linear cousins. In
the case of the as-rigid-as-possible optimization, the bottleneck is typically
the large number of polar decompositions necessary to recover best fit
rotations for each edge-set (i.e. for each triangle, tetrahedron, or vertex
cell). Even if this code is optimized, the number of primary degrees of freedom
is tied to the discretization level, despite the deformations' low frequency
behavior.</p>
<p>This invites two routes toward fast non-linear optimization. First, is it
necessary (or even advantageous) to find so many best-fit rotations? Second,
can we reduce the degrees of freedom to better reflect the frequency of the
desired deformations.</p>
<p>Taken in turn, these optimizations culminate in a method which optimizes over
the space of linear blend skinning deformations spanned by high-quality weights
(i.e. manually painted ones or bounded biharmonic weights). This space is a
low-dimensional subspace of all possible mesh deformations, captured by writing
linear blend skinning in matrix form:</p>
<p><span><span class="MathJax_Preview">\mathbf{X}' = \mathbf{M}\mathbf{T}</span><script type="math/tex">\mathbf{X}' = \mathbf{M}\mathbf{T}</script></span></p>
<p>where the mesh vertex positions in the <span><span class="MathJax_Preview">n \times 3</span><script type="math/tex">n \times 3</script></span> matrix <span><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> are
replaced by a linear combination of a small number of degrees of freedom in the
<span><span class="MathJax_Preview">(3+1)m \times 3</span><script type="math/tex">(3+1)m \times 3</script></span> stack of transposed "handle" transformations. Swapping in
<span><span class="MathJax_Preview">\mathbf{M}\mathbf{T}</span><script type="math/tex">\mathbf{M}\mathbf{T}</script></span> for <span><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> in the ARAP energies above immediately
sees performance gains during the global solve step as <span><span class="MathJax_Preview">m &lt;&lt; n</span><script type="math/tex">m << n</script></span>.</p>
<p>The complexity of the local step---fitting rotations---is still bound
to the original mesh discretization. However, if the skinning is well behaved,
we can make the assumption that places on the shape with similar skinning
weights will deform similarly and thus imply similar best-fit rotations.
Therefore, we cluster edge-sets according to their representation in
<em>weight-space</em>: where a vertex <span><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> takes the coordinates
<span><span class="MathJax_Preview">[w_1(\mathbf{x}),w_2(\mathbf{x}),\dots,w_m(\mathbf{x})]</span><script type="math/tex">[w_1(\mathbf{x}),w_2(\mathbf{x}),\dots,w_m(\mathbf{x})]</script></span>. The number of
clustered edge-sets show diminishing returns on the deformation quality so we
may choose a small number of clusters, proportional to the number of skinning
weight functions (rather than the number of discrete mesh vertices).</p>
<p>This proposed deformation model [#jacobson_2012][], can simultaneously be seen as a
fast, subspace optimization for ARAP and as an automatic method for finding
<em>the best</em> skinning transformation degrees of freedom.</p>
<p>A variety of user interfaces are supported via linear equality constraints on
the skinning transformations associated with handles. To fix a transformation
entirely we simply add the constraint:</p>
<p><span><span class="MathJax_Preview">\left(\begin{array}{cccc}
 1 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 1 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 1 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{T}}_i^T,</span><script type="math/tex">\left(\begin{array}{cccc}
 1 & 0 & 0 & 0\\
 0 & 1 & 0 & 0\\
 0 & 0 & 1 & 0\\
 0 & 0 & 0 & 1\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{T}}_i^T,</script></span></p>
<p>where <span><span class="MathJax_Preview">\hat{\mathbf{T}}_i^T</span><script type="math/tex">\hat{\mathbf{T}}_i^T</script></span> is the <span><span class="MathJax_Preview">(3+1) \times 3</span><script type="math/tex">(3+1) \times 3</script></span> transposed fixed
transformation for handle <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.</p>
<p>To fix only the origin of a handle, we add a constraint requiring the
transformation to interpolate a point in space (typically the centroid of all
points with <span><span class="MathJax_Preview">w_i = 1</span><script type="math/tex">w_i = 1</script></span>:</p>
<p><span><span class="MathJax_Preview">\mathbf{c}'^T\mathbf{T}_i^T = \mathbf{c}^T,</span><script type="math/tex">\mathbf{c}'^T\mathbf{T}_i^T = \mathbf{c}^T,</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{c}^T</span><script type="math/tex">\mathbf{c}^T</script></span> is the <span><span class="MathJax_Preview">1 \times (3+1)</span><script type="math/tex">1 \times (3+1)</script></span> position of the point at rest in
transposed homogeneous coordinates, and <span><span class="MathJax_Preview">\mathbf{c}'^T</span><script type="math/tex">\mathbf{c}'^T</script></span> the point given by the
user.</p>
<p>We can similarly fix just the linear part of the transformation at a handle,
freeing the translation component (producing a "chickenhead" effect):</p>
<p><span><span class="MathJax_Preview">\left(\begin{array}{cccc}
 1&amp;0&amp;0&amp;0\\
 0&amp;1&amp;0&amp;0\\
 0&amp;0&amp;1&amp;0\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{L}}_i^T,</span><script type="math/tex">\left(\begin{array}{cccc}
 1&0&0&0\\
 0&1&0&0\\
 0&0&1&0\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{L}}_i^T,</script></span></p>
<p>where <span><span class="MathJax_Preview">\hat{\mathbf{L}}_i^T</span><script type="math/tex">\hat{\mathbf{L}}_i^T</script></span> is the fixed <span><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> linear part of the
transformation at handle <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.</p>
<p>And lastly we can allow the user to entirely <em>free</em> the transformation's
degrees of freedom, delegating the optimization to find the best possible
values for all elements. To do this, we simply abstain from adding a
corresponding constraint.</p>
<h3 id="arap-with-grouped-edge-sets">ARAP with grouped edge-sets<a class="headerlink" href="#arap-with-grouped-edge-sets" title="Permanent link">&para;</a></h3>
<p>Being a subspace method, an immediate disadvantage is the reduced degrees of
freedom. This brings performance, but in some situations limits behavior too
much. In such cases one can use the skinning subspace to build an effective
clustering of rotation edge-sets for a traditional ARAP optimization: forgoing
the subspace substitution. This has an two-fold effect. The cost of the
rotation fitting, local step drastically reduces, and the deformations are
"regularized" according the clusters. From a high level point of view, if the
clusters are derived from skinning weights, then they will discourage bending,
especially along isolines of the weight functions. If handles are not known in
advance, one could also cluster according to a "geodesic embedding" like the
biharmonic distance embedding.</p>
<p>In this light, we can think of the "spokes+rims" style surface ARAP as a (slight and
redundant) clustering of the per-triangle edge-sets.</p>
<p><img alt="The example FastAutomaticSkinningTransformations compares a full (slow)
ARAP deformation on a detailed shape (left of middle), to ARAP with grouped
rotation edge sets (right of middle), to the very fast subpsace method
(right)." src="../images/armadillo-fast.jpg" /></p>
<h2 id="biharmonic-coordinates">Biharmonic Coordinates<a class="headerlink" href="#biharmonic-coordinates" title="Permanent link">&para;</a></h2>
<p>Linear blend skinning (as <a href="#boundedbiharmonicweights">above</a>) deforms a mesh by
propagating <em>full affine transformations</em> at handles (bones, points, regions,
etc.) to the rest of the shape via weights. Another deformation framework,
called "generalized barycentric coordinates", is a special case of linear blend
skinning [#jacobson_skinning_course_2014][]: transformations are restricted to
<em>pure translations</em> and weights are required to retain <em>affine precision</em>. This
latter requirement means that we can write the rest-position of any vertex in
the mesh as the weighted combination of the control handle locations:</p>
<p><span><span class="MathJax_Preview">\mathbf{x} = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i,</span><script type="math/tex">\mathbf{x} = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i,</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{c}_i</span><script type="math/tex">\mathbf{c}_i</script></span> is the rest position of the <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th control point. This
simplifies the deformation formula at run-time. We can simply take the new
position of each point of the shape to be the weighted combination of the
<em>translated</em> control point positions:</p>
<p><span><span class="MathJax_Preview">\mathbf{x}' = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i'.</span><script type="math/tex">\mathbf{x}' = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i'.</script></span></p>
<p>There are <em>many</em> different flavors of "generalized barycentric coordinates"
(see table in "Automatic Methods" section,
[#jacobson_skinning_course_2014][]). The vague goal of "generalized barycentric
coordinates" is to capture as many properties of simplicial barycentric
coordinates (e.g. for triangles in 2D and tetrahedral in 3D) for larger sets of
points or polyhedra. Some generalized barycentric coordinates can be computed
in closed form; others require optimization-based precomputation. Nearly all
flavors require connectivity information describing how the control points form
a external polyhedron around the input shape: a cage. However, a recent
techinique does not require a cage [#wang_bc_2015][]. This method ensures
affine precision during optimization over weights of a smoothness energy with
affine functions in its kernel:</p>
<p><span><span class="MathJax_Preview">\mathop{\text{min}}_\mathbf{W}\,\, \text{trace}(\frac{1}{2}\mathbf{W}^T \mathbf{A}
 \mathbf{W}), \text{subject to: } \mathbf{C} = \mathbf{W}\mathbf{C}</span><script type="math/tex">\mathop{\text{min}}_\mathbf{W}\,\, \text{trace}(\frac{1}{2}\mathbf{W}^T \mathbf{A}
 \mathbf{W}), \text{subject to: } \mathbf{C} = \mathbf{W}\mathbf{C}</script></span></p>
<p>subject to interpolation constraints at selected vertices. If <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> has
affine functions in its kernel---that is, if <span><span class="MathJax_Preview">\mathbf{A}\mathbf{V} = 0</span><script type="math/tex">\mathbf{A}\mathbf{V} = 0</script></span>---then
the weights <span><span class="MathJax_Preview">\mathbf{W}</span><script type="math/tex">\mathbf{W}</script></span> will retain affine precision and we'll have that:</p>
<p><span><span class="MathJax_Preview">\mathbf{V} = \mathbf{W}\mathbf{C}</span><script type="math/tex">\mathbf{V} = \mathbf{W}\mathbf{C}</script></span></p>
<p>the matrix form of the equality above. The proposed way to define <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>
is to construct a matrix <span><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> that measures the Laplacian at all
interior vertices <em>and at all boundary vertices</em>. The <em>usual</em> definition of the
discrete Laplacian (e.g. what libigl returns from <code class="codehilite">igl::cotmatrix</code>), measures
the Laplacian of a function for interior vertices, but measures the Laplacian
of a function <em>minus</em> the normal derivative of a function for boundary
vertices. Thus, we can let:</p>
<p><span><span class="MathJax_Preview">\mathbf{K} = \mathbf{L} + \mathbf{N}</span><script type="math/tex">\mathbf{K} = \mathbf{L} + \mathbf{N}</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span> is the <em>usual</em> Laplacian and <span><span class="MathJax_Preview">\mathbf{N}</span><script type="math/tex">\mathbf{N}</script></span> is matrix that
computes normal derivatives of a piecewise-linear function at boundary vertices
of a mesh. Then <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> is taken as quadratic form computing the square of
the integral-average of <span><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> applied to a function and integrated over
the mesh:</p>
<p><span><span class="MathJax_Preview">\mathbf{A} = (\mathbf{M}^{-1}\mathbf{K})^2_\mathbf{M} = \mathbf{K}^T \mathbf{M}^{-1}
 \mathbf{K}.</span><script type="math/tex">\mathbf{A} = (\mathbf{M}^{-1}\mathbf{K})^2_\mathbf{M} = \mathbf{K}^T \mathbf{M}^{-1}
 \mathbf{K}.</script></span></p>
<p>Since the Laplacian <span><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> is a second-order derivative it measures zero on affine
functions, thus <span><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> has affine functions in its null space. A short
derivation proves that this implies <span><span class="MathJax_Preview">\mathbf{W}</span><script type="math/tex">\mathbf{W}</script></span> will be affine precise (see
[#wang_bc_2015][]).</p>
<p>Minimizers of this "squared Laplacian" energy are in some sense <em>discrete
biharmonic functions</em>. Thus they're dubbed "biharmonic coordinates" (not the
same as <em>bounded biharmonic weights</em>, which are <em>not</em> generalized barycentric
coordinates).</p>
<p>In libigl, one can compute biharmonic coordinates given a mesh <code class="codehilite">(V,F)</code> and a
list <code class="codehilite">S</code> of selected control points or control regions (which act like skinning
handles):</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">biharmonic_coordinates</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">W</span><span class="p">);</span>
</pre></div>

<p><img alt="(Example 407) shows a physics
simulation on a coarse orange mesh. The vertices of this mesh become control
points for a biharmonic coordinates deformation of the blue high-resolution
mesh." src="../images/octopus-biharmonic-coordinates-physics.gif" /></p>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../chapter-3/" title="Chapter 3: Matrices and Linear Algebra" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Chapter 3: Matrices and Linear Algebra
              </span>
            </div>
          </a>
        
        
          <a href="../chapter-5/" title="Chapter 5: Parametrization" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Chapter 5: Parametrization
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.8eb9be28.js"></script>
      
      <script>app.initialize({version:"0.17.3",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
      
    
  </body>
</html>