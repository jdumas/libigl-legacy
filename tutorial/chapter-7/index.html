



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-0.17.3, mkdocs-material-2.7.0">
    
    
      
        <title>Chapter 7: Miscellaneous - libigl</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.78aab2dc.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.6079476c.css">
      
    
    
      <script src="../../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="light-blue" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <a href="#miscellaneous-chapter7miscellaneous" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="libigl" class="md-header-nav__button md-logo">
          
            <i class="md-icon">details</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                libigl
              </span>
              <span class="md-header-nav__topic">
                Chapter 7: Miscellaneous
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <span class="md-nav__button md-logo">
      
        <i class="md-icon">details</i>
      
    </span>
    libigl
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      Tutorial
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Tutorial
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-1/" title="Chapter 1: Introduction to libigl" class="md-nav__link">
      Chapter 1: Introduction to libigl
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-2/" title="Chapter 2: Discrete Geometric Quantities and Operators" class="md-nav__link">
      Chapter 2: Discrete Geometric Quantities and Operators
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-3/" title="Chapter 3: Matrices and Linear Algebra" class="md-nav__link">
      Chapter 3: Matrices and Linear Algebra
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-4/" title="Chapter 4: Shape Deformation" class="md-nav__link">
      Chapter 4: Shape Deformation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-5/" title="Chapter 5: Parametrization" class="md-nav__link">
      Chapter 5: Parametrization
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-6/" title="Chapter 6: External libraries" class="md-nav__link">
      Chapter 6: External libraries
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="toc">
        Chapter 7: Miscellaneous
      </label>
    
    <a href="./" title="Chapter 7: Miscellaneous" class="md-nav__link md-nav__link--active">
      Chapter 7: Miscellaneous
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#mesh-statistics-meshstatistics" title="Mesh Statistics [meshstatistics]" class="md-nav__link">
    Mesh Statistics [meshstatistics]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#generalized-winding-number-generalizedwindingnumber" title="Generalized Winding Number [generalizedwindingnumber]" class="md-nav__link">
    Generalized Winding Number [generalizedwindingnumber]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mesh-decimation-meshdecimation" title="Mesh Decimation [meshdecimation]" class="md-nav__link">
    Mesh Decimation [meshdecimation]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#signed-distances-signeddistances" title="Signed Distances [signeddistances]" class="md-nav__link">
    Signed Distances [signeddistances]
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#point-location" title="Point location" class="md-nav__link">
    Point location
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#closest-points" title="Closest points" class="md-nav__link">
    Closest points
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signed-distance" title="Signed distance" class="md-nav__link">
    Signed distance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#marching-cubes-marchingcubes" title="Marching Cubes [marchingcubes]" class="md-nav__link">
    Marching Cubes [marchingcubes]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#facet-orientation-facetorientation" title="Facet Orientation [facetorientation]" class="md-nav__link">
    Facet Orientation [facetorientation]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#swept-volume-sweptvolume" title="Swept Volume [sweptvolume]" class="md-nav__link">
    Swept Volume [sweptvolume]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#picking-pickingverticesandfaces" title="Picking [pickingverticesandfaces]" class="md-nav__link">
    Picking [pickingverticesandfaces]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector-field-visualization-vectorfieldvisualizer" title="Vector Field Visualization [vectorfieldvisualizer]" class="md-nav__link">
    Vector Field Visualization [vectorfieldvisualizer]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scalable-locally-injective-maps-slim" title="Scalable Locally Injective Maps [slim]" class="md-nav__link">
    Scalable Locally Injective Maps [slim]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#subdivision-surfaces-subdivision" title="Subdivision surfaces [subdivision]" class="md-nav__link">
    Subdivision surfaces [subdivision]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#data-smoothing-datasmoothing" title="Data smoothing [datasmoothing]" class="md-nav__link">
    Data smoothing [datasmoothing]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shapeup-projections-shapeup" title="ShapeUp Projections [shapeup]" class="md-nav__link">
    ShapeUp Projections [shapeup]
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chapter-8/" title="Chapter 8: Outlook for continuing development" class="md-nav__link">
      Chapter 8: Outlook for continuing development
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Compilation
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Compilation
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../example-project/" title="Example Project" class="md-nav__link">
      Example Project
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../static-library/" title="Static Library" class="md-nav__link">
      Static Library
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../third-party/" title="External Dependencies" class="md-nav__link">
      External Dependencies
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Contributing
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Contributing
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../style-guidelines/" title="Style Guidelines" class="md-nav__link">
      Style Guidelines
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../CONTRIBUTING/" title="Bug Report" class="md-nav__link">
      Bug Report
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../before-submitting-pull-request/" title="Creating a Pull Request" class="md-nav__link">
      Creating a Pull Request
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unit-tests/" title="Unit Tests" class="md-nav__link">
      Unit Tests
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Misc
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Misc
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../coding-guidelines/" title="Coding Tips" class="md-nav__link">
      Coding Tips
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../faq/" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      About
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        About
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../RELEASE_HISTORY/" title="Release History" class="md-nav__link">
      Release History
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../LICENSE/" title="License" class="md-nav__link">
      License
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#mesh-statistics-meshstatistics" title="Mesh Statistics [meshstatistics]" class="md-nav__link">
    Mesh Statistics [meshstatistics]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#generalized-winding-number-generalizedwindingnumber" title="Generalized Winding Number [generalizedwindingnumber]" class="md-nav__link">
    Generalized Winding Number [generalizedwindingnumber]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mesh-decimation-meshdecimation" title="Mesh Decimation [meshdecimation]" class="md-nav__link">
    Mesh Decimation [meshdecimation]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#signed-distances-signeddistances" title="Signed Distances [signeddistances]" class="md-nav__link">
    Signed Distances [signeddistances]
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#point-location" title="Point location" class="md-nav__link">
    Point location
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#closest-points" title="Closest points" class="md-nav__link">
    Closest points
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signed-distance" title="Signed distance" class="md-nav__link">
    Signed distance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#marching-cubes-marchingcubes" title="Marching Cubes [marchingcubes]" class="md-nav__link">
    Marching Cubes [marchingcubes]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#facet-orientation-facetorientation" title="Facet Orientation [facetorientation]" class="md-nav__link">
    Facet Orientation [facetorientation]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#swept-volume-sweptvolume" title="Swept Volume [sweptvolume]" class="md-nav__link">
    Swept Volume [sweptvolume]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#picking-pickingverticesandfaces" title="Picking [pickingverticesandfaces]" class="md-nav__link">
    Picking [pickingverticesandfaces]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector-field-visualization-vectorfieldvisualizer" title="Vector Field Visualization [vectorfieldvisualizer]" class="md-nav__link">
    Vector Field Visualization [vectorfieldvisualizer]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scalable-locally-injective-maps-slim" title="Scalable Locally Injective Maps [slim]" class="md-nav__link">
    Scalable Locally Injective Maps [slim]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#subdivision-surfaces-subdivision" title="Subdivision surfaces [subdivision]" class="md-nav__link">
    Subdivision surfaces [subdivision]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#data-smoothing-datasmoothing" title="Data smoothing [datasmoothing]" class="md-nav__link">
    Data smoothing [datasmoothing]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shapeup-projections-shapeup" title="ShapeUp Projections [shapeup]" class="md-nav__link">
    ShapeUp Projections [shapeup]
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="miscellaneous-chapter7miscellaneous">Miscellaneous [chapter7:miscellaneous]<a class="headerlink" href="#miscellaneous-chapter7miscellaneous" title="Permanent link">&para;</a></h1>
<p>Libigl contains a <em>wide</em> variety of geometry processing tools and functions for
dealing with meshes and the linear algebra related to them: far too many to
discuss in this introductory tutorial. We've pulled out a couple of the
interesting functions in this chapter to highlight.</p>
<h2 id="mesh-statistics-meshstatistics"><a href="#meshstatistics">Mesh Statistics</a> [meshstatistics]<a class="headerlink" href="#mesh-statistics-meshstatistics" title="Permanent link">&para;</a></h2>
<p>Libigl contains various mesh statistics, including face angles, face areas and
the detection of singular vertices, which are vertices with more or less than 6
neighbours in triangulations or 4 in quadrangulations.</p>
<p>The example <a href="../701_Statistics/main.cpp">Statistics</a> computes these quantities and
does a basic statistic analysis that allows to estimate the isometry and
regularity of a mesh:</p>
<div class="codehilite"><pre><span></span>Irregular vertices:
<span class="m">136</span>/2400 <span class="o">(</span><span class="m">5</span>.67%<span class="o">)</span>
Areas <span class="o">(</span>Min/Max<span class="o">)</span>/Avg_Area Sigma:
<span class="m">0</span>.01/5.33 <span class="o">(</span><span class="m">0</span>.87<span class="o">)</span>
Angles in degrees <span class="o">(</span>Min/Max<span class="o">)</span> Sigma:
<span class="m">17</span>.21/171.79 <span class="o">(</span><span class="m">15</span>.36<span class="o">)</span>
</pre></div>

<p>The first row contains the number and percentage of irregular vertices, which
is particularly important for quadrilateral meshes when they are used to define
subdivision surfaces: every singular point will result in a point of the
surface that is only C^1.</p>
<p>The second row reports the area of the minimal element, maximal element and the
standard deviation.  These numbers are normalized by the mean area, so in the
example above 5.33 max area means that the biggest face is 5 times larger than
the average face. An ideal isotropic mesh would have both min and max area
close to 1.</p>
<p>The third row measures the face angles, which should be close to 60 degrees (90
for quads) in a perfectly regular triangulation. For FEM purposes, the closer
the angles are to 60 degrees the more stable will the optimization be. In this
case, it is clear that the mesh is of bad quality and it will probably result
in artifacts if used for solving PDEs.</p>
<h2 id="generalized-winding-number-generalizedwindingnumber"><a href="#generalizedwindingnumber">Generalized Winding Number</a> [generalizedwindingnumber]<a class="headerlink" href="#generalized-winding-number-generalizedwindingnumber" title="Permanent link">&para;</a></h2>
<p>The problem of tetrahedralizing the interior of closed watertight surface mesh
is a difficult, but well-posed problem (see our [Tetgen wrappers][tetrahedralizationofclosedsurfaces]).  But
black-box tet-meshers like TetGen will <em>refuse</em> input triangle meshes with
self-intersections, open boundaries, non-manifold edges from multiple connected
components.
The problem is two-fold: self-intersections present contradictory facet
constraints and self-intersections/open-boundaries/non-manifold edges make the
problem of determining inside from outside ill-posed without further
assumptions.</p>
<p>The first problem is <em>easily</em> solved by "resolving" all self-intersections.
That is, meshing intersecting triangles so that intersects occur exactly at
edges and vertices. This is accomplished using <code class="codehilite">igl::selfintersect</code>.</p>
<p>TetGen can usually tetrahedralize the convex hull of this "resolved" mesh, and
then the problem becomes determining which of these tets are <em>inside</em> the input
mesh and which are outside. That is, which should be kept and which should be
removed.</p>
<p>The "Generalized Winding Number" is a robust method for determined
inside and outside for troublesome meshes [#jacobson_2013][].  The generalized
winding number with respect to <code class="codehilite">(V,F)</code> at some point <span><span class="MathJax_Preview">\mathbf{p} \in
\mathcal{R}^3</span><script type="math/tex">\mathbf{p} \in
\mathcal{R}^3</script></span> is defined as scalar function:</p>
<p><span><span class="MathJax_Preview"><span><span class="MathJax_Preview">w(\mathbf{p}) = \sum\limits_{f_i\in F} \frac{1}{4\pi}\Omega_{f_i}(\mathbf{p})</span><script type="math/tex">w(\mathbf{p}) = \sum\limits_{f_i\in F} \frac{1}{4\pi}\Omega_{f_i}(\mathbf{p})</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">w(\mathbf{p}) = \sum\limits_{f_i\in F} \frac{1}{4\pi}\Omega_{f_i}(\mathbf{p})</span><script type="math/tex">w(\mathbf{p}) = \sum\limits_{f_i\in F} \frac{1}{4\pi}\Omega_{f_i}(\mathbf{p})</script></span></script></span></p>
<p>where <span><span class="MathJax_Preview">\Omega_{f_i}</span><script type="math/tex">\Omega_{f_i}</script></span> is the <em>solid angle</em> subtended by <span><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span> (the ith face in
<code class="codehilite">F</code>) at the point <span><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>. This solid angle contribution is a simple,
closed-form expression involving <code class="codehilite">atan2</code> and some dot-products.</p>
<p>If <code class="codehilite">(V,F)</code> <em>does</em> form a closed watertight surface, then <span><span class="MathJax_Preview">w(\mathbf{p})=1</span><script type="math/tex">w(\mathbf{p})=1</script></span> if
<span><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> lies inside <code class="codehilite">(V,F)</code> and <span><span class="MathJax_Preview">w(\mathbf{p})=0</span><script type="math/tex">w(\mathbf{p})=0</script></span> if outside <code class="codehilite">(V,F)</code>.  If
<code class="codehilite">(V,F)</code> is closed but overlaps itself then <span><span class="MathJax_Preview">w(\mathbf{p})</span><script type="math/tex">w(\mathbf{p})</script></span> is an integer value
counting how many (signed) times <code class="codehilite">(V,F)</code> <em>wraps</em> around <span><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>.  Finally,
if <code class="codehilite">(V,F)</code> is not closed or not even manifold (but at least consistently
oriented), then <span><span class="MathJax_Preview">w(\mathbf{p})</span><script type="math/tex">w(\mathbf{p})</script></span> tends smoothly toward 1 as <span><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> is
<em>more</em> inside <code class="codehilite">(V,F)</code>, and toward 0 as <span><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> is more outside.</p>
<p><img alt="Example 702 computes the
generalized winding number function for a tetrahedral mesh inside a cat with
holes and self intersections (gold). The silver mesh is surface of the
extracted interior tets, and slices show the winding number function on all
tets in the convex hull: blue (~0), green (~1), yellow
(~2)." src="../images/big-sigcat-winding-number.gif" /></p>
<h2 id="mesh-decimation-meshdecimation"><a href="#meshdecimation">Mesh Decimation</a> [meshdecimation]<a class="headerlink" href="#mesh-decimation-meshdecimation" title="Permanent link">&para;</a></h2>
<p>The study of mesh simplification or <em>decimation</em> is nearly as old as meshes
themselves. Given a high resolution mesh with too many triangles, find a "well
approximating" low resolution mesh with far fewer triangles. By now there are a
variety of different paradigms for solving this problem and state-of-the-art
methods are fairly advanced.</p>
<p>One family of mesh decimation methods operates by successively remove elements
from the mesh. In particular, Hoppe advocates for successively remove or rather
collapsing edges [#hoppe_1996][]. The generic form of this technique is to
construct a sequence of n meshes from the initial high-resolution mesh <span><span class="MathJax_Preview">M_0</span><script type="math/tex">M_0</script></span> to
the lowest resolution mesh <span><span class="MathJax_Preview">M_n</span><script type="math/tex">M_n</script></span> by collapsing a single edge:</p>
<p><span><span class="MathJax_Preview">M_0 \mathop{\longrightarrow}_\text{edge collapse}
  M_1 \mathop{\longrightarrow}_\text{edge collapse}
  \dots \mathop{\longrightarrow}_\text{edge collapse}
  M_{n-1} \mathop{\longrightarrow}_\text{edge collapse} M_n.</span><script type="math/tex">M_0 \mathop{\longrightarrow}_\text{edge collapse}
  M_1 \mathop{\longrightarrow}_\text{edge collapse}
  \dots \mathop{\longrightarrow}_\text{edge collapse}
  M_{n-1} \mathop{\longrightarrow}_\text{edge collapse} M_n.</script></span></p>
<p>Hoppe's original method and subsequent follow-up works propose various ways to
choose the next edge to collapse in this sequence. Using a cost-based paradigm,
one can maintain a priority queue of edges based on their "cost" (how much
"worse" will my approximation be if I remove this edge?). The cheapest edge is
collapsed and costs of neighboring edges are updated.</p>
<p>In order to maintain the topology (e.g. if the mesh is combinatorially as
sphere or a torus etc.), one should assign infinite cost to edges whose
collapse would alter the mesh topology. Indeed this happens if and only if the
number of mutual neighbors of the endpoints of the collapsing edge is not
exactly two!</p>
<p>If there exists a third shared vertex, then another face will be removed, but 2
edges will be removed. This can result in unwanted holes or non-manifold
"flaps".</p>
<p><img alt="A valid edge collapse and an invalid edge collapse." src="../images/edge-collapse.jpg" /></p>
<blockquote>
<p>There is also a one-off condition that no edges of a tetrahedron should be
collapsed.</p>
</blockquote>
<p>Because libigl (purposefully) does not center its implementations around a
dynamic mesh data structure (e.g. half-edge datastructure), support for
topology changes are limited. Nonetheless, libigl has support for isolated edge
collapses, sequences of edge-collapses (each in O(log) time) and priority queue
based decimation.</p>
<p>The simplest is <code class="codehilite">igl::decimation</code>. By calling</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">decimate</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">G</span><span class="p">);</span>
</pre></div>

<p>the mesh <code class="codehilite">(V,F)</code> will be decimated to a new mesh <code class="codehilite">(U,G)</code> so that <code class="codehilite">G</code> has at
most <code class="codehilite">1000</code> faces. This uses default (naive) criteria for determining the cost
of an edge collapse and the placement of the merged vertex. Shortest edges are
collapsed first, and merged vertices are placed at edge midpoints.</p>
<p>One can also provide function handles (<code class="codehilite">c++</code> lambda functions are convenient
here) <code class="codehilite">cost_and_placement</code> and <code class="codehilite">stopping_condition</code> for determining the
cost/placement of an edge collapse and the stopping condition respectively. For
example, the default version above is implemented as:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">decimate</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">shortest_edge_and_midpoint</span><span class="p">,</span><span class="n">max_m</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">G</span><span class="p">);</span>
</pre></div>

<p>where <code class="codehilite">shortest_edge_and_midpoint</code> assign the edge's length as cost and its
midpoint as the merged vertex placement and <code class="codehilite">max_m</code> counts the current number
of faces (valid collapses decrease count by 2) and returns <code class="codehilite">true</code> if the count
drops below <code class="codehilite">m=1000</code>.</p>
<p>One can also scratch deeper inside the decimation loop and call
<code class="codehilite">igl::collapse_edge</code> directly. In order to operate efficiently, this routine
needs more than the usual <code class="codehilite">(V,F)</code> mesh representation. We need <code class="codehilite">E</code> a list of
edge indices, where <code class="codehilite">E.row(i) --&gt; [s,d]</code>; we need <code class="codehilite">EMAP</code> which maps the
"half"-edges of each triangle in <code class="codehilite">F</code> to its corresponding edge in <code class="codehilite">E</code> so that
<code class="codehilite">E.row(EMAP(f+i*F.rows)) --&gt; [s,d]</code> if the edge across from the ith corner of the
fth face is <code class="codehilite">[s,d]</code> (up to orientation); we need <code class="codehilite">EF</code> and <code class="codehilite">EI</code> which keep track
of the faces incident on each edge and across from which corner of those faces
the edges appears, so that <code class="codehilite">EF(e,o) = f</code> and <code class="codehilite">EI(e,o) = i</code> means that the edge
<code class="codehilite">E.row(e) --&gt; [s,d]</code> appears in the fth face across from its ith corner (for
<code class="codehilite">o=0</code> the edge orientations should match, for <code class="codehilite">o=1</code> the orientations are
opposite).</p>
<p>When a collapse occurs, the sizes of the <code class="codehilite">F</code>,<code class="codehilite">E</code>, etc. matrices do not change.
Rather rows corresponding to "removed" faces and edges are set to a special
constant value <code class="codehilite">IGL_COLLAPSE_EDGE_NULL</code>. Doing this ensures that we're able to
remove edges in truly constant time O(1).</p>
<blockquote>
<p>Conveniently <code class="codehilite">IGL_COLLAPSE_EDGE_NULL==0</code>. This means most OPENGL style renderings of <code class="codehilite">F</code>
will simply draw a bunch of 0-area triangles at the first vertex.</p>
</blockquote>
<p>The following will collapse the first
edge and place its merged vertex at the origin:</p>
<p><div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">collapse_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">RowVector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">EMAP</span><span class="p">,</span><span class="n">EF</span><span class="p">,</span><span class="n">EI</span><span class="p">);</span>
</pre></div>
If valid, then <code class="codehilite">V</code>,<code class="codehilite">F</code>,<code class="codehilite">E</code>,<code class="codehilite">EF</code>,<code class="codehilite">EI</code> are adjusted accordingly.</p>
<p>This is powerful, but low level. To build a decimator around this you'd need to
keep track which edges are left to collapse and which to collapse next.
Fortunately, libigl also exposes a priority queue based edge collapse with
function handles to adjust costs and placements.</p>
<p>The priority queue is implemented as a (ordered) set <code class="codehilite">Q</code> or (cost,edge index)
pairs and a list of iterators <code class="codehilite">Qit</code> so that <code class="codehilite">Qit[e]</code> reveals the iterator in
<code class="codehilite">Q</code> corresponding to the eth edge. Placements are stored in a #E list of
positions <code class="codehilite">C</code>. When the following is called:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">collapse_edge</span><span class="p">(</span><span class="n">cost_and_placement</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">EMAP</span><span class="p">,</span><span class="n">EF</span><span class="p">,</span><span class="n">EI</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">Qit</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</pre></div>

<p>the lowest cost edge collapse according to <code class="codehilite">Q</code> is attempted. If valid, then
<code class="codehilite">V</code>,<code class="codehilite">F</code>,etc. are adjusted accordingly and that edge is "popped" from <code class="codehilite">Q</code>. Using
<code class="codehilite">Qit</code> its neighboring edges are also popped from <code class="codehilite">Q</code> and re-inserted after
updating their costs according to <code class="codehilite">cost_and_placement</code>, new placements are
remembered in <code class="codehilite">C</code>. If not valid, then the edge is "popped" from <code class="codehilite">Q</code> and
reinserted with infinite cost.</p>
<p><img alt="Example 703 conducts edge collapses on the fertility
model." src="../images/fertility-edge-collapse.gif" /></p>
<p>The <a href="../703_Decimation/main.cpp">Example 703</a> demonstrates using this priority
queue based approach with the simple shortest-edge-midpoint cost/placement
strategy discussed above.</p>
<h2 id="signed-distances-signeddistances"><a href="#signeddistances">Signed Distances</a> [signeddistances]<a class="headerlink" href="#signed-distances-signeddistances" title="Permanent link">&para;</a></h2>
<p>In the [Generalized Winding Number section][generalizedwindingnumber], we
examined a robust method for determining whether points lie inside or outside
of a given triangle soup mesh. Libigl complements this algorithm with
accelerated signed and unsigned distance queries and "in element" queries for
planar triangle meshes and 3D tetrahedral meshes. These routines make use of
libigl's general purpose axis-aligned bounding box hierarchy (<code class="codehilite">igl/AABB.h</code>).
This class is lightweight and---by design---does not store a copy of the mesh
(taking it as inputs to its member functions instead).</p>
<h3 id="point-location">Point location<a class="headerlink" href="#point-location" title="Permanent link">&para;</a></h3>
<p>For tetrahedral meshes, this is useful for "in element" or "point location"
queries: given a point <span><span class="MathJax_Preview">\mathbf{q}\in\mathcal{R}^3</span><script type="math/tex">\mathbf{q}\in\mathcal{R}^3</script></span> and a tetrahedral mesh
<span><span class="MathJax_Preview">(V,T)</span><script type="math/tex">(V,T)</script></span> determine in which tetrahedron <span><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> lies. This is accomplished
in libigl for a tet mesh <code class="codehilite">V,T</code> and a list of query points in the rows of <code class="codehilite">Q</code>
via the <code class="codehilite">igl::in_element()</code>:</p>
<div class="codehilite"><pre><span></span><span class="c1">// Initialize AABB tree</span>
<span class="n">igl</span><span class="o">::</span><span class="n">AABB</span><span class="o">&lt;</span><span class="n">MatrixXd</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">;</span>
<span class="n">tree</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">T</span><span class="p">);</span>
<span class="n">VectorXi</span> <span class="n">I</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">in_element</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">tree</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</pre></div>

<p>the resulting vector <code class="codehilite">I</code> is a list of indices into <code class="codehilite">T</code> revealing the <em>first</em>
tetrahedron found to contain the corresponding point in <code class="codehilite">Q</code>.</p>
<p>For overlapping meshes, a point <span><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> may belong to more than one
tetrahedron. In those cases, one can find them all (not just the first) by
using the <code class="codehilite">igl::in_element</code> overload with a <code class="codehilite">SparseMatrix</code> as the output:</p>
<div class="codehilite"><pre><span></span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">I</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">in_element</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">tree</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</pre></div>

<p>now each row of <code class="codehilite">I</code> reveals whether each tet contains the corresponding row in
<code class="codehilite">Q</code>: <code class="codehilite">I(q,e)!=0</code> means that point <code class="codehilite">q</code> is in element <code class="codehilite">e</code>.</p>
<h3 id="closest-points">Closest points<a class="headerlink" href="#closest-points" title="Permanent link">&para;</a></h3>
<p>For Triangle meshes, we use the AABB tree to accelerate point-mesh closest
point queries: given a mesh <span><span class="MathJax_Preview">(V,F)</span><script type="math/tex">(V,F)</script></span> and a query point
<span><span class="MathJax_Preview">\mathbf{q}\in\mathcal{R}^3</span><script type="math/tex">\mathbf{q}\in\mathcal{R}^3</script></span> find the closest point <span><span class="MathJax_Preview">\mathbf{c} \in (V,F)</span><script type="math/tex">\mathbf{c} \in (V,F)</script></span>
(where <span><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span> is not necessarily a vertex of <span><span class="MathJax_Preview">(V,F)</span><script type="math/tex">(V,F)</script></span>). This is
accomplished for a triangle mesh <code class="codehilite">V,F</code> and a list of points in the rows of <code class="codehilite">P</code>
via <code class="codehilite">igl::point_mesh_squared_distance</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">VectorXd</span> <span class="n">sqrD</span><span class="p">;</span>
<span class="n">VectorXi</span> <span class="n">I</span><span class="p">;</span>
<span class="n">MatrixXd</span> <span class="n">C</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">point_mesh_squared_distance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">sqrD</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</pre></div>

<p>the output <code class="codehilite">sqrD</code> contains the (unsigned) squared distance from each point in
<code class="codehilite">P</code> to its closest point given in <code class="codehilite">C</code> which lies on the element in <code class="codehilite">F</code> given by
<code class="codehilite">I</code> (e.g. from which one could recover barycentric coordinates, using
<code class="codehilite">igl::barycentric_coordinates</code>).</p>
<p>If the mesh <code class="codehilite">V,F</code> is static, but the point set <code class="codehilite">P</code> is changing dynamically then
it's best to reuse the AABB hierarchy that's being built during
<code class="codehilite">igl::point_mesh_squared_distance</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">AABB</span> <span class="n">tree</span><span class="p">;</span>
<span class="n">tree</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">);</span>
<span class="n">tree</span><span class="p">.</span><span class="n">squared_distance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">sqrD</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
<span class="p">...</span> <span class="c1">// P changes, but (V,F) does not</span>
<span class="n">tree</span><span class="p">.</span><span class="n">squared_distance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">sqrD</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</pre></div>

<h3 id="signed-distance">Signed distance<a class="headerlink" href="#signed-distance" title="Permanent link">&para;</a></h3>
<p>Finally, from the closest point or the winding number it's possible to <em>sign</em>
this distance. In <code class="codehilite">igl::signed_distance</code> we provide two methods for signing:
the so-called "pseudo-normal test" [#baerentzen_2005][] and the generalized
winding number [#jacobson_2013][].</p>
<p>The pseudo-normal test (see also <code class="codehilite">igl::pseudonormal_test</code>) assumes the input
mesh is a watertight (closed, non-self-intersecting, manifold) mesh. Then given
a query point <span><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> and its closest point <span><span class="MathJax_Preview">\mathbf{c} \in (V,F)</span><script type="math/tex">\mathbf{c} \in (V,F)</script></span>, it
carefully chooses an outward normal <span><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span> at <span><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span> so that
<span><span class="MathJax_Preview">\text{sign}(\mathbf{q}-\mathbf{c})\cdot \mathbf{n}</span><script type="math/tex">\text{sign}(\mathbf{q}-\mathbf{c})\cdot \mathbf{n}</script></span> reveals whether
<span><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> is inside <span><span class="MathJax_Preview">(V,F)</span><script type="math/tex">(V,F)</script></span>: -1, or outside: +1. This is a fast <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> test
once <span><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span> is located, but may fail if <code class="codehilite">V,F</code> is not watertight.</p>
<p>An alternative is to use the [generalized winding
number][generalizedwindingnumber] to determine the sign. This is very robust to
unclean meshes <code class="codehilite">V,F</code> but slower: something like <span><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> once <span><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span>
is located.</p>
<p>In either case, the interface via <code class="codehilite">igl::signed_distance</code> is:</p>
<div class="codehilite"><pre><span></span><span class="c1">// Choose type of signing to use</span>
<span class="n">igl</span><span class="o">::</span><span class="n">SignedDistanceType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">SIGNED_DISTANCE_TYPE_PSEUDONORMAL</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">signed_distance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">sign_type</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
</pre></div>

<p>the outputs are as above for <code class="codehilite">igl::point_mesh_squared_distance</code> but now <code class="codehilite">S</code>
contains signed (unsquared) distances and the extra output <code class="codehilite">N</code> (only set when
<code class="codehilite">type == SIGNED_DISTANCE_TYPE_PSEUDON</code>) contains the normals used for signing
with the pseudo-normal test.</p>
<p><img alt="Example 704 computes signed distance on
slices through the bunny." src="../images/bunny-signed-distance.gif" /></p>
<h2 id="marching-cubes-marchingcubes"><a href="#marchingcubes">Marching Cubes</a> [marchingcubes]<a class="headerlink" href="#marching-cubes-marchingcubes" title="Permanent link">&para;</a></h2>
<p>Often 3D data is captured as scalar field defined over space <span><span class="MathJax_Preview">f(\mathbf{x}) :
\mathcal{R}^3 \rightarrow \mathcal{R}</span><script type="math/tex">f(\mathbf{x}) :
\mathcal{R}^3 \rightarrow \mathcal{R}</script></span>. Lurking within this field,
<em>iso-surfaces</em> of the scalar field are often salient geometric objects. The
iso-surface at value <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is composed of all points <span><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> in
<span><span class="MathJax_Preview">\mathcal{R}^3</span><script type="math/tex">\mathcal{R}^3</script></span> such that <span><span class="MathJax_Preview">f(\mathbf{x}) = v</span><script type="math/tex">f(\mathbf{x}) = v</script></span>. A core problem in geometry
processing is to extract an iso-surface as a triangle mesh for further
mesh-based processing or visualization. This is referred to as iso-contouring.</p>
<p>"Marching Cubes" [#lorensen_1987] is a <a href="https://en.wikipedia.org/wiki/Marching_cubes">famous
method</a> for iso-contouring
tri-linear functions <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> on a regular lattice (aka grid). The core idea of this
method is to contour the iso-surface passing through each cell  (if it does at
all) with a predefined topology (aka connectivity) chosen from a look up table
depending on the function values at each vertex of the cell. The method
iterates ("marches") over all cells ("cubes") in the grid and stitches together
the final, watertight mesh.</p>
<p>In libigl, <code class="codehilite">igl::marching_cubes</code> constructs a triangle mesh <code class="codehilite">(V,F)</code> from an
input scalar field <code class="codehilite">S</code> sampled at vertex locations <code class="codehilite">GV</code> of a <code class="codehilite">nx</code> by <code class="codehilite">ny</code> by
<code class="codehilite">nz</code> regular grid:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">marching_cubes</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">GV</span><span class="p">,</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">);</span>
</pre></div>

<p><img alt="(Example 705) samples signed distance to the
input mesh (left) and then reconstructs the surface using
marching cubes to contour the 0-level set (center). For comparison, clamping
this signed distance field to an indicator function and contouring reveals
serious aliasing artifacts." src="../images/armadillo-marching-cubes.jpg" /></p>
<h2 id="facet-orientation-facetorientation"><a href="#facetorientation">Facet Orientation</a> [facetorientation]<a class="headerlink" href="#facet-orientation-facetorientation" title="Permanent link">&para;</a></h2>
<p>Models from the web occasionally arrive <em>unorientated</em> in the sense that
the orderings of each triangles vertices do not consistently agree. Determining
a consistent facet orientation for a mesh is essential for two-sided lighting
(e.g., a cloth with red velvet on one side and gold silk on the other side) and
for inside-outside determination(e.g., using <a href="#generalizedwindingnumber">generalized winding
numbers</a>).</p>
<p>For (open) surfaces representing two-sided sheets, libigl provides a routine to
force consistent orientations within each orientable patch
(<code class="codehilite">igl::orientable_patches</code>) of a mesh:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">bfs_orient</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">FF</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</pre></div>

<p>This simple routine will use breadth-first search on each patch of the mesh to
enforce a consistent facet orientation in the output faces <code class="codehilite">FF</code>.</p>
<p>For (closed or nearly closed) surfaces representing the boundary of a solid
object, libigl provides a routine to reorient faces so that the vertex ordering
corresponds to a counter-clockwise ordering of the vertices with a
right-hand-rule normal pointing outward. This method [#takayama14][] assumes
that <a href="https://www.reddit.com/r/askscience/comments/32otgx/which_as_a_is_more_empty_an_atom_or_the_universe/">most of the universe is
empty</a>.
That is, most points in space are outside of the solid object than inside.
Points are sampled over surface patches. For each sample point, rays are shot
into both hemispheres to compute average of the (distance weighted) ambient
occlusion on each side. A patch is oriented so that the outward side is <em>less
occluded</em> (lighter, i.e., facing more void space).</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">embree</span><span class="o">::</span><span class="n">reorient_facets_raycast</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">FF</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</pre></div>

<p>The boolean vector <code class="codehilite">I</code> reveals which rows of <code class="codehilite">F</code> have been flipped in <code class="codehilite">FF</code>.</p>
<p><img alt="(Example 706) loads a truck model with
inconsistent orientations (back facing triangles shown darker). Orientable
patches are uniquely colored and then oriented to face outward (middle left).
Alternatively, each individual triangle is considered a &quot;patch&quot; (middle right)
and oriented outward independently." src="../images/truck-facet-orientation.jpg" /></p>
<h2 id="swept-volume-sweptvolume"><a href="#sweptvolume">Swept Volume</a> [sweptvolume]<a class="headerlink" href="#swept-volume-sweptvolume" title="Permanent link">&para;</a></h2>
<p>The swept volume <span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span> of a moving solid object <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> can be defined as any point in
space such that at one moment in time the point lies inside the solid. In other
words, it is the union of the solid object transformed by the rigid motion
<span><span class="MathJax_Preview">f(t)</span><script type="math/tex">f(t)</script></span> over time:</p>
<p><span><span class="MathJax_Preview">S = \bigcup \limits_{t\in [0,1]} f(t) A.</span><script type="math/tex">S = \bigcup \limits_{t\in [0,1]} f(t) A.</script></span></p>
<p>The surface of the swept volume of a solid bounded by a triangle mesh
undergoing a rigid motion with non-trivial rotation is <em><strong>not</strong></em> a surface
exactly representably by triangle mesh: it will be a piecewise-ruled surface.</p>
<p>To see this, consider the surface swept by a single edge's line segment as it
performs a screw motion.</p>
<p>This means that if we'd like to the surface of the swept volume of a triangle
mesh undergoing a rigid motion and we'd like the output to be another triangle
mesh, then we're going to have to be happy with some amount of approximation
error.</p>
<p>With this in mind, the simplest method for computing an approximate swept
volume is by exploiting an alternative definition of the swept volume based on
signed distances:</p>
<p><span><span class="MathJax_Preview">S = \left\{ \mathbf{p}\ \middle| \ d(\mathbf{p},\partial S) &lt; 0 \right\} = \left\{ \mathbf{p}\
\middle|\
\min\limits_{t \in [0,1]} d(\mathbf{p},f(t)\ \partial A) &lt; 0 \right\}</span><script type="math/tex">S = \left\{ \mathbf{p}\ \middle| \ d(\mathbf{p},\partial S) < 0 \right\} = \left\{ \mathbf{p}\
\middle|\
\min\limits_{t \in [0,1]} d(\mathbf{p},f(t)\ \partial A) < 0 \right\}</script></span></p>
<p>If <span><span class="MathJax_Preview">\partial A</span><script type="math/tex">\partial A</script></span> is a triangle mesh, then we can approximate this by 1)
discretizing time at a finite step of steps <span><span class="MathJax_Preview">[0,\Delta t,2\Delta t, \dots, 1]</span><script type="math/tex">[0,\Delta t,2\Delta t, \dots, 1]</script></span>
and by 2) discretizing space with a regular grid and representing the distance
field using trilinear interpolation of grid values. Finally the output mesh,
<span><span class="MathJax_Preview">\partial S</span><script type="math/tex">\partial S</script></span> is approximated by contouring using Marching Cubes
[#lorensen_1987].</p>
<p>This method is similar to one described by Schroeder et al. in 1994
[#schroeder_1994], and the one used in conjunction with boolean operations by
Garg et al. 2016 [#garg_2016].</p>
<p>In libigl, if your input solid's surface is represented by <code class="codehilite">(V,F)</code> then the
output surface mesh will be <code class="codehilite">(SV,SF)</code> after calling:</p>
<div class="codehilite"><pre><span></span><span class="n">igl</span><span class="o">::</span><span class="n">copyleft</span><span class="o">::</span><span class="n">swept_volume</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">num_time_steps</span><span class="p">,</span><span class="n">grid_size</span><span class="p">,</span><span class="n">isolevel</span><span class="p">,</span><span class="n">SV</span><span class="p">,</span><span class="n">SF</span><span class="p">);</span>
</pre></div>

<p>The <code class="codehilite">isolevel</code> parameter can be set to zero to approximate the exact swept
volume, greater than zero to approximate a positive offset of the swept volume
or less than zero to approximate a negative offset.</p>
<p><img alt="(Example 707) computes
the surface of the swept volume (silver) of the bunny model undergoing a rigid
motion (gold)." src="../images/bunny-swept-volume.gif" /></p>
<h2 id="picking-pickingverticesandfaces"><a href="#pickingverticesandfaces">Picking</a> [pickingverticesandfaces]<a class="headerlink" href="#picking-pickingverticesandfaces" title="Permanent link">&para;</a></h2>
<p>Picking vertices and faces using the mouse is very common in geometry
processing applications. While this might seem a simple operation, its
implementation is not straightforward. Libigl contains a function that solves this problem using the
<a href="https://software.intel.com/en-us/articles/embree-photo-realistic-ray-tracing-kernels">Embree</a>
raycaster. Its usage is demonstrated in <a href="../708_Picking/main.cpp">Example 708</a>:</p>
<div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">igl</span><span class="o">::</span><span class="n">unproject_onto_mesh</span><span class="p">(</span>
  <span class="n">Vector2f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
  <span class="n">F</span><span class="p">,</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">view</span> <span class="o">*</span> <span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">model</span><span class="p">,</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">proj</span><span class="p">,</span>
  <span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">viewport</span><span class="p">,</span>
  <span class="o">*</span><span class="n">ei</span><span class="p">,</span>
  <span class="n">fid</span><span class="p">,</span>
  <span class="n">vid</span><span class="p">);</span>
</pre></div>

<p>This function casts a ray from the view plane in the view direction. Variables
<code class="codehilite">x</code> and <code class="codehilite">y</code> are
the mouse screen coordinates; <code class="codehilite">view</code>, <code class="codehilite">model</code>, <code class="codehilite">proj</code> are the view, model and
projection matrix respectively; <code class="codehilite">viewport</code> is the viewport in OpenGL format;
<code class="codehilite">ei</code>
contains a <a href="http://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Bounding Volume
Hierarchy</a> constructed
by Embree, and <code class="codehilite">fid</code> and <code class="codehilite">vid</code> are the picked face and vertex, respectively.</p>
<p><img alt="(Example 708) Picking via ray casting. The selected
vertices are colored in red." src="../images/607_Picking.png" /></p>
<h2 id="vector-field-visualization-vectorfieldvisualizer"><a href="#vectorfieldvisualizer">Vector Field Visualization</a> [vectorfieldvisualizer]<a class="headerlink" href="#vector-field-visualization-vectorfieldvisualizer" title="Permanent link">&para;</a></h2>
<p>Vector fields on surfaces are commonly visualized by tracing [streamlines] (<a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines</a>). Libigl
supports the seeding and tracing of streamlines, for both simple vector fields
and for N-rosy fields. The seeds for the streamlines are initialized using <code class="codehilite">streamlines_init</code>,
and the lines are traced using <code class="codehilite">streamlines_next</code>. Each call to <code class="codehilite">streamlines_next</code> extends
each line by one triangle, allowing interactive rendering of the traced lines, as demonstrated
in <a href="../709_VectorFieldVisualizer/main.cpp">Example 709</a>.</p>
<p><img alt="(Example 709) Interactive streamlines tracing." src="../images/streamlines.jpg" /></p>
<h2 id="scalable-locally-injective-maps-slim"><a href="#slim">Scalable Locally Injective Maps</a> [slim]<a class="headerlink" href="#scalable-locally-injective-maps-slim" title="Permanent link">&para;</a></h2>
<p>The Scalable Locally Injective Maps [#rabinovich_2016] algorithm allows to
compute locally injective maps on massive datasets. The algorithm shares many
similarities with ARAP, but uses a reweighting scheme to minimize arbitrary
distortion energies, including those that prevent the introduction of flips.</p>
<p><a href="../710_SLIM/main.cpp">Example 710</a> contains three demos: (1) an example of large
scale 2D parametrization, (2) an example of 2D deformation with soft
constraints, and (3) an example of 3D deformation with soft constraints. The
implementation in libigl is self-contained and relies on Eigen for the solution
of the linear system used in the global step. An optimized version that relies
on Pardiso is available
<a href="https://github.com/MichaelRabinovich/Scalable-Locally-Injective-Mappings">here</a>.</p>
<p><img alt="A locally injective parametrization of a mesh with 50k faces is computed
using the SLIM algorithm in 10 iterations." src="../images/slim.png" /></p>
<h2 id="subdivision-surfaces-subdivision"><a href="#subdivision">Subdivision surfaces</a> [subdivision]<a class="headerlink" href="#subdivision-surfaces-subdivision" title="Permanent link">&para;</a></h2>
<p>Given a coarse mesh (aka cage) with vertices <code class="codehilite">V</code> and faces <code class="codehilite">F</code>, one can createa
higher-resolution mesh with more vertices and faces by <em>subdividing</em> every
face. That is, each coarse triangle in the input is replaced by many smaller
triangles. Libigl has three different methods for subdividing a triangle mesh.</p>
<p>An "in plane" subdivision method will not change the point set or carrier
surface of the mesh. New vertices are added on the planes of existing triangles
and vertices surviving from the original mesh are not moved.</p>
<p>By adding new faces, a subdivision algorithm changes the <em>combinatorics</em> of the
mesh. The change in combinatorics and the formula for positioning the
high-resolution vertices is called the "subdivision rule".</p>
<p>For example, in the <em>in plane</em> subdivision method of <code class="codehilite">igl::upsample</code>, vertices
are added at the midpoint of every edge: <span><span class="MathJax_Preview">v_{ab} = \frac{1}{2}(v_a + v_b)</span><script type="math/tex">v_{ab} = \frac{1}{2}(v_a + v_b)</script></span> and
each triangle <span><span class="MathJax_Preview">(i_a,i_b,i_c)</span><script type="math/tex">(i_a,i_b,i_c)</script></span> is replaced with four triangles:
<span><span class="MathJax_Preview">(i_a,i_{ab},i_{ca})</span><script type="math/tex">(i_a,i_{ab},i_{ca})</script></span>, <span><span class="MathJax_Preview">(i_b,i_{bc},i_{ab})</span><script type="math/tex">(i_b,i_{bc},i_{ab})</script></span>, <span><span class="MathJax_Preview">(i_{ab},i_{bc},i_{ca})</span><script type="math/tex">(i_{ab},i_{bc},i_{ca})</script></span>, and
<span><span class="MathJax_Preview">(i_{bc},i_{c},i_{ca})</span><script type="math/tex">(i_{bc},i_{c},i_{ca})</script></span>. This process may be applied recursively, resulting in
a finer and finer mesh.</p>
<p>The subdivision method of <code class="codehilite">igl::loop</code> is not in plane. The vertices of the
refined mesh are moved to weight combinations of their neighbors: the mesh is
smoothed as it is refined [#loop_1987]. This and other <em>smooth subdivision</em>
methods can be understood as generalizations of spline curves to surfaces. In
particular the Loop subdivision method will converge to a <span><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span> surface as we
consider the limit of recursive applications of subdivision. Away from
"irregular" or "extraordinary" vertices (vertices of the original cage with
valence not equal to 6), the surface is <span><span class="MathJax_Preview">C^2</span><script type="math/tex">C^2</script></span>. The combinatorics (connectivity
and number of faces) of <code class="codehilite">igl::loop</code> and <code class="codehilite">igl::upsample</code> are identical: the only
difference is that the vertices have been smoothed in <code class="codehilite">igl::loop</code>.</p>
<p>Finally, libigl also implements a form of <em>in plane</em> "false barycentric
subdivision" in <code class="codehilite">igl::false_barycentric_subdivision</code>. This method simply adds
the barycenter of every triangle as a new vertex <span><span class="MathJax_Preview">v_{abc}</span><script type="math/tex">v_{abc}</script></span> and replaces each
triangle with three triangles <span><span class="MathJax_Preview">(i_a,i_b,i_{abc})</span><script type="math/tex">(i_a,i_b,i_{abc})</script></span>, <span><span class="MathJax_Preview">(i_b,i_c,i_{abc})</span><script type="math/tex">(i_b,i_c,i_{abc})</script></span>, and
<span><span class="MathJax_Preview">(i_c,i_a,i_{abc})</span><script type="math/tex">(i_c,i_a,i_{abc})</script></span>. In contrast to <code class="codehilite">igl::upsample</code>, this method will create
triangles with smaller and smaller internal angles and new vertices will sample
the carrier surfaces with extreme bias.</p>
<p><img alt="The original coarse mesh and three different subdivision methods:
igl::upsample, igl::loop and
igl::false_barycentric_subdivision." src="../images/decimated-knight-subdivision.gif" /></p>
<h2 id="data-smoothing-datasmoothing"><a href="#datasmoothing">Data smoothing</a> [datasmoothing]<a class="headerlink" href="#data-smoothing-datasmoothing" title="Permanent link">&para;</a></h2>
<p>A noisy function <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> defined on a surface <span><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> can be smoothed using an
energy minimization that balances a smoothing term <span><span class="MathJax_Preview">E_S</span><script type="math/tex">E_S</script></span> with a quadratic
fitting term:</p>
<p><span><span class="MathJax_Preview">u = \operatorname{argmin}_u \alpha E_S(u) + (1-\alpha)\int_\Omega ||u-f||^2 dx</span><script type="math/tex">u = \operatorname{argmin}_u \alpha E_S(u) + (1-\alpha)\int_\Omega ||u-f||^2 dx</script></span></p>
<p>The parameter <span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> determines how aggressively the function is smoothed.</p>
<p>A classical choice for the smoothness energy is the Laplacian energy of the
function with zero Neumann boundary conditions, which is a form of the
biharmonic energy. It is constructed using the cotangent Laplacian <code class="codehilite">L</code> and
the mass matrix <code class="codehilite">M</code>: <code class="codehilite">QL = L&#39;*(M\L)</code>. Because of the implicit zero Neumann
boundary conditions however, the function behavior is significantly warped at
the boundary if <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> does not have zero normal gradient at the boundary.</p>
<p>In #[stein_2017] it is suggested to use the Biharmonic energy with natural
Hessian boundary conditions instead, which corresponds to the hessian energy
with the matrix <code class="codehilite">QH = H&#39;*(M2\H)</code>, where <code class="codehilite">H</code> is a finite element Hessian and
<code class="codehilite">M2</code> is a stacked mass matrix. The matrices <code class="codehilite">H</code> and <code class="codehilite">QH</code> are implemented in
libigl as <code class="codehilite">igl::hessian</code> and <code class="codehilite">igl::hessian_energy</code> respectively. An example
of how to use the function is given in <a href="../712_DataSmoothing/main.cpp">Example 712</a>.</p>
<p>In the following image the differences between the Laplacian energy with
zero Neumann boundary conditions and the Hessian energy can be clearly seen:
whereas the zero Neumann boundary condition in the third image bias the isolines
of the function to be perpendicular to the boundary, the Hessian energy gives
an unbiased result.</p>
<p><img alt="(Example 712) From left to right: a function
on the beetle mesh, the function with added noise, the result of smoothing
with the Laplacian energy and zero Neumann boundary conditions, and the
result of smoothing with the Hessian energy." src="../images/712_beetles.jpg" /></p>
<h2 id="shapeup-projections-shapeup"><a href="#shapeup">ShapeUp Projections</a> [shapeup]<a class="headerlink" href="#shapeup-projections-shapeup" title="Permanent link">&para;</a></h2>
<p>Our input is a set of points <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> (not necessarily part of any mesh), and a set of constraints <span><span class="MathJax_Preview">S=\left\{S_1,S_2,...S_m\right\}</span><script type="math/tex">S=\left\{S_1,S_2,...S_m\right\}</script></span>, where each constraint is defined on a different, and sparse, subset of <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span>. We wish to create a new set of points <span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> that are close to the original set <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> (each point with corresponding indices), while adhering to the constraints. Other objectives, such as smoothness, can be employed. The constraints can be nonlinear, which makes the problem nonconvex, difficult, and without a guaranteed global optimum. A very popular lightweight approach to such problems is a local-global iterative algorithm, comprising these two steps:</p>
<p>For iteration <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>:
1. <em>Local step</em>: compute the projections of the set <span><span class="MathJax_Preview">P_{k-1}</span><script type="math/tex">P_{k-1}</script></span> onto <span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>, individually per constraint; that would mean fragmenting each point that appears in multiple constraints. That can be a nonlinear operation, but if the constraints are sparse, it is a a set of many small systems.
2. <em>Global step</em>: integrate the set <span><span class="MathJax_Preview">P_k</span><script type="math/tex">P_k</script></span> to be as close as possible to the projected fragmented set, with auxiliary objective functions possible. That results in a global, but quadratic objective function. Moreover, the resulting linear system has a constant matrix, and therefore can be pre-factored.</p>
<p>The version we implement in libigl is the general version described by [#bouaziz_2012], and is in two files: <code class="codehilite">&lt;igl/shapeup.h&gt;</code> and <code class="codehilite">&lt;igl/shapeup_local_projections.h&gt;</code>. A demo implementing regularity constraints (creating a mesh in which each face is as regular as possible) is in <a href="../713_Shapeup/main.cpp">Example 713</a>. </p>
<p>The local step is instantiated by a function of type <code class="codehilite">igl::shapeup_projection_function</code>. The global step is done by two functions: <code class="codehilite">igl::shapeup_precomputation()</code>, which precomputes the matrices required for the global step, and <code class="codehilite">igl::shapeup_solve()</code>, which solves the problem, according to the initial solution <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> and the input local projection function. The data struct <code class="codehilite">igl::ShapeUpData</code> contains the information necessary to run the algorithm, and can be configured; for instance, the self-explanatory variable <code class="codehilite">Maxiterations</code>.</p>
<p>The global step minimizes the following energy:</p>
<div>
<div class="MathJax_Preview">E_{total}=\lambda_{shape}E_{shape}+\lambda_{close}E_{close}+\lambda_{smooth}E_{smooth},</div>
<script type="math/tex; mode=display">E_{total}=\lambda_{shape}E_{shape}+\lambda_{close}E_{close}+\lambda_{smooth}E_{smooth},</script>
</div>
<p>where the <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> coefficients are encoded in <code class="codehilite">igl::ShapeUpData</code>, and can be updated <strong>prior</strong> to calling <code class="codehilite">igl::shapeup_precomputation()</code>. The <span><span class="MathJax_Preview">E_{shape}</span><script type="math/tex">E_{shape}</script></span> component is the integration energy (fitting <span><span class="MathJax_Preview">P_k</span><script type="math/tex">P_k</script></span> to the local projections). The <span><span class="MathJax_Preview">E_{close}</span><script type="math/tex">E_{close}</script></span> component is adherence to positional constraints, given by <code class="codehilite">b</code> and <code class="codehilite">bc</code> parameters. The <span><span class="MathJax_Preview">E_{smooth}</span><script type="math/tex">E_{smooth}</script></span> component is an optional objective function, to minimize differences (in the Dirichlet sense) between points, encodes by "edges" in parameter <code class="codehilite">E</code>. Both <span><span class="MathJax_Preview">E_{close}</span><script type="math/tex">E_{close}</script></span> and <span><span class="MathJax_Preview">E_{shape}</span><script type="math/tex">E_{shape}</script></span> are also weighted by <code class="codehilite">wClose</code> and <code class="codehilite">wShape</code> function parameters, respectively.</p>
<p><img alt="(Example 713) The half-tunnel mesh (left) has been optimized to be almost perfectly regular (right). The color scale is between [0,0.05][0,0.05], measuring the average normalized deviation of the angles of each face from 90^{\circ}90^{\circ}." src="../images/713_ShapeUp.png" /></p>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../chapter-6/" title="Chapter 6: External libraries" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Chapter 6: External libraries
              </span>
            </div>
          </a>
        
        
          <a href="../chapter-8/" title="Chapter 8: Outlook for continuing development" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Chapter 8: Outlook for continuing development
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.8eb9be28.js"></script>
      
      <script>app.initialize({version:"0.17.3",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
      
    
  </body>
</html>